--- src/main.cpp
+++ src/main.cpp
@@ -401,27 +401,24 @@
 
 
 
-  static bool    s_ttsThrottling = false;
-  static uint8_t s_savedThreads  = 0;  // 初期値は何でもOK（開始時に保存するので）
-
+    // ---- TTS中のマイニング負荷制御（捨てない版） ----
+  // ・再生中: applyMiningPolicyForTts() が pause する（JOB維持）
+  // ・取得中/準備中: スレッドを止める(0)とJOBを捨てやすいので、ここでは "yield強化" に留める
+  static bool s_yieldStrong = false;
 
   if (g_tts.isBusy()) {
-    if (!s_ttsThrottling) {
-      s_savedThreads = getMiningActiveThreads();
-      setMiningActiveThreads(MC_TTS_ACTIVE_THREADS_DURING_TTS);
-      s_ttsThrottling = true;
-      mc_logf("[TTS] mining throttle: threads %u -> %u",
-              (unsigned)s_savedThreads, (unsigned)MC_TTS_ACTIVE_THREADS_DURING_TTS);
+    if (!s_yieldStrong) {
+      setMiningYieldProfile(MiningYieldStrong());
+      s_yieldStrong = true;
+      mc_logf("[TTS] mining yield: Strong");
     }
   } else {
-    if (s_ttsThrottling) {
-      setMiningActiveThreads(s_savedThreads);
-      s_ttsThrottling = false;
-      mc_logf("[TTS] mining restore: threads -> %u", (unsigned)s_savedThreads);
-    }
-  }
-
-
-
-  delay(2);
+    if (s_yieldStrong) {
+      setMiningYieldProfile(MiningYieldNormal());
+      s_yieldStrong = false;
+      mc_logf("[TTS] mining yield: Normal");
+    }
+  }
+
+delay(2);
 }

--- src/mining_task.cpp
+++ src/mining_task.cpp
@@ -187,6 +187,17 @@
 }
 
   for (uint32_t nonce = 0; nonce <= maxNonce; ++nonce) {
+    // ---- ★ Pause: keep current JOB, stop only the CPU-heavy loop ----
+    // When paused, we simply yield here and resume from the same nonce.
+    // (No disconnect / no job drop)
+    if (g_miningPaused) {
+      waitWhilePaused_();
+      // If this thread got disabled while paused, abort cleanly.
+      if (tidx >= 0 && tidx >= (int)g_mining_active_threads) {
+        return DUCO_ABORTED;
+      }
+    }
+
     int nlen = u32_to_dec(nonce_ptr, nonce);
 
     if (g_shaMutex) xSemaphoreTake(g_shaMutex, portMAX_DELAY);