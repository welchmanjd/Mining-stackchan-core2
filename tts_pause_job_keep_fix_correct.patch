diff --git a/src/main.cpp b/src/main.cpp
index 262d351..277d252 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -399,25 +399,31 @@ void loop() {
     displaySleeping = true;
   }
 
-
-
-  static bool    s_ttsThrottling = false;
-  static uint8_t s_savedThreads  = 0;  // 初期値は何でもOK（開始時に保存するので）
-
+  // ---- TTS中のマイニング負荷制御（捨てない版） ----
+  // ・再生中: applyMiningPolicyForTts() が pause する（JOB維持）
+  // ・取得中/準備中: STOP(0)はJOBを捨てやすいので、ここでは yield 強化に留める
+  // ・Attention(WHAT?) が yield を管理している時は、そちらを優先する
+  static bool s_ttsYieldApplied = false;
+  static MiningYieldProfile s_ttsSavedYield = MiningYieldNormal();
+  static bool s_ttsSavedYieldValid = false;
 
   if (g_tts.isBusy()) {
-    if (!s_ttsThrottling) {
-      s_savedThreads = getMiningActiveThreads();
-      setMiningActiveThreads(MC_TTS_ACTIVE_THREADS_DURING_TTS);
-      s_ttsThrottling = true;
-      mc_logf("[TTS] mining throttle: threads %u -> %u",
-              (unsigned)s_savedThreads, (unsigned)MC_TTS_ACTIVE_THREADS_DURING_TTS);
+    if (!s_ttsYieldApplied && !g_attentionActive) {
+      s_ttsSavedYield = getMiningYieldProfile();
+      s_ttsSavedYieldValid = true;
+      setMiningYieldProfile(MiningYieldStrong());
+      s_ttsYieldApplied = true;
+      mc_logf("[TTS] mining yield: Strong");
     }
   } else {
-    if (s_ttsThrottling) {
-      setMiningActiveThreads(s_savedThreads);
-      s_ttsThrottling = false;
-      mc_logf("[TTS] mining restore: threads -> %u", (unsigned)s_savedThreads);
+    if (s_ttsYieldApplied && !g_attentionActive) {
+      if (s_ttsSavedYieldValid) {
+        setMiningYieldProfile(s_ttsSavedYield);
+      } else {
+        setMiningYieldProfile(MiningYieldNormal());
+      }
+      s_ttsYieldApplied = false;
+      mc_logf("[TTS] mining yield: restore");
     }
   }
 
diff --git a/src/mining_task.cpp b/src/mining_task.cpp
index 0d1ca77..c98674e 100644
--- a/src/mining_task.cpp
+++ b/src/mining_task.cpp
@@ -187,6 +187,16 @@ if (tidx >= 0 && tidx >= (int)g_mining_active_threads) {
 }
 
   for (uint32_t nonce = 0; nonce <= maxNonce; ++nonce) {
+    // ---- ★ Pause: keep current JOB, stop only the CPU-heavy loop ----
+    // When paused, we yield here and resume from the same nonce (no disconnect / no job drop).
+    if (g_miningPaused) {
+      waitWhilePaused_();
+      // If this thread got disabled while paused, abort cleanly.
+      if (tidx >= 0 && tidx >= (int)g_mining_active_threads) {
+        return DUCO_ABORTED;
+      }
+    }
+
     int nlen = u32_to_dec(nonce_ptr, nonce);
 
     if (g_shaMutex) xSemaphoreTake(g_shaMutex, portMAX_DELAY);
